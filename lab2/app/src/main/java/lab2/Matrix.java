/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lab2;



import java.util.Arrays;


public class Matrix {
    private  double[][] values;
    private Config config = new Config();

    // Matrix initialization
    public void MatrixInit()
    {
        config.setConfig(0,0);
    }

    public void MatrixInit(int rows, int columns)
    {
        if (rows < 0 || columns < 0)
        {
            throw new NumberFormatException("Invalid columns or rows input, must be at least 0");
        }
        values = new double[rows][columns];
        config.setConfig(rows, columns);
    }

    public void MatrixInit(Matrix matrix)
    {
        
        config.setConfig(matrix.config.Rows, matrix.config.Columns);
        values = new double[config.Rows][config.Columns];
        for (int indexOfRow = 0; indexOfRow < getNumberOfRows(); indexOfRow++) 
        {
            System.arraycopy(matrix.values[indexOfRow], 0, values[indexOfRow], 0, getNumberOfColumns());
        }
    }

    public static Matrix createDiagonalMatrix(double... diagonal)
    {
        return null;
    }

    public static Matrix createIdentityMatrix(int rows, int columns)
    {
        return null;
    }
    //Funcions that helps us get something
    public Config getMatrixConfiguration()
    {
        return config;
    }

    public int getNumberOfRows()
    {
        return config.Rows;
    }

    public int getNumberOfColumns()
    {
        return config.Columns;
    }

    public double get(int indexOfRow, int indexOfColumn)
    {
        Compability(indexOfRow, indexOfColumn);     
        return values[indexOfRow][indexOfColumn];
    }

    public Matrix getRow(int indexOfRow)
    {
        Compability(indexOfRow, 0);
        Matrix row = new Matrix();
        row.MatrixInit(1, config.Columns);
        System.arraycopy(values[indexOfRow], 0, row.values[0], 0, config.Columns);
        return row;
    }

    public Matrix getColumn(int indexOfColumn)
    {
        Compability(0, indexOfColumn);
        Matrix column = new Matrix();
        column.MatrixInit(config.Rows, 1);
        for (int indexOfRow = 0; indexOfRow < getNumberOfRows(); indexOfRow++) 
        {
            column.values[indexOfRow][0] = values[indexOfRow][indexOfColumn];
        }
        return column;
    }
    //Seting functions
    public void set(int indexOfRow, int indexOfColumn, double value)
    {
        Compability(indexOfRow, indexOfColumn);
        values[indexOfRow][indexOfColumn] = value;
    }

    public void setRow(int indexOfRow,  double... row)
    {
        Compability(indexOfRow, 0);
        if (getNumberOfColumns() != row.length) 
        {
            throw new NumberFormatException("Wrong Input");
        }
        System.arraycopy(row, 0, values[indexOfRow], 0, getNumberOfColumns());
    }

    public void setColumn(int indexOfColumn, double... column)
    {
        Compability(0, indexOfColumn);
        if (getNumberOfRows() != column.length) 
        {
            throw new NumberFormatException("Wrong Input");
        }
        for (int indexOfRow = 0; indexOfRow < getNumberOfRows(); indexOfRow++) {
            values[indexOfRow][indexOfColumn] = column[indexOfRow];
        }
    }
    //Equals and hasCode
    @Override
    public boolean equals(Object obj) 
    {
        if (this == obj) 
        {
            return true;
        }
        
        if (getClass() != obj.getClass()) 
        {
            return false;
        }
        Matrix matrix = new Matrix();
        matrix.MatrixInit((Matrix) obj);
        return Arrays.deepEquals(values, matrix.values);
    }

    @Override
    public int hashCode() 
    {
        return Arrays.deepHashCode(values);
    }
    //Functions that do some math`s action
    public Matrix add(Matrix matrix)
    {
        if (matrix.getNumberOfRows() != config.Rows || matrix.getNumberOfColumns() != config.Columns) 
        {
            throw new NumberFormatException("Wrong matrix dimmension");
        }
        for (int indexOfRow = 0; indexOfRow  < getNumberOfRows(); indexOfRow ++) 
        {
            for (int indexOfColumn  = 0; indexOfColumn < getNumberOfColumns(); indexOfColumn++) 
            {
                values[indexOfRow][indexOfColumn] += matrix.values[indexOfRow][indexOfColumn];
            }
        }
        return this;
    }

    public Matrix multiply(double scalar) 
    {
        for (int i = 0; i < getNumberOfRows(); i++) 
        {
            for (int j = 0; j < getNumberOfColumns(); j++) 
            {
                values[i][j] *= scalar;
            }
        }
        return this;
    }

    public Matrix multiply(Matrix matrix) 
    {
        if (getNumberOfColumns() != matrix.getNumberOfRows()) 
        {
            throw new NumberFormatException();
        }
        double[][] result = new double[getNumberOfRows()][matrix.getNumberOfColumns()];
        int n = getNumberOfColumns();
        for (int indexOfRow = 0; indexOfRow < result.length; indexOfRow++) 
        {
            for (int indexOfColumn = 0; indexOfColumn < result[0].length; indexOfColumn++) 
            {
                for (int i = 0; i < n; i++)
                {
                    result[indexOfRow][indexOfColumn] += values[indexOfRow][i] * matrix.values[i][indexOfColumn];
                }
            }
        }
        values = result;
        return this;
    }

    public Matrix transposeMatrix()
    {
        return null;
    }


    //Matrix visualization

    public String getString()
    {
        return Arrays.deepToString(values).replace("],", "]\n");
    }
    // check for bonds
    private void Compability(int row, int column) 
    {
        if (row < 0 || row >= getNumberOfRows() || column < 0 || column >= getNumberOfColumns()) 
        {
            throw new NumberFormatException("Wrong Input");
        }
    }
    //random input
    public static Matrix createRandomRow(int NumberOfColumns) {
        if (NumberOfColumns < 0) 
        {
            throw new NumberFormatException("Wrong input");
        }
        Matrix result = new Matrix();
        result.MatrixInit(1, NumberOfColumns);

        for (int columnI = 0; columnI < NumberOfColumns; columnI++) 
        {
            result.values[0][columnI] = Math.random();
        }
        return result;
    }

    public static Matrix createRandomColumn(int NumberOfRows) {
        if (NumberOfRows < 0) 
        {
            throw new NumberFormatException("Wrong input");
        }
        Matrix result = new Matrix();
        result.MatrixInit(NumberOfRows, 1);
        for (int rowI = 0; rowI < NumberOfRows; rowI++) 
        {
            result.values[rowI][0] = Math.random();
        }
        return result;
    }


    public static Matrix createDiagonal(double... diagonal) {
        Matrix result = new Matrix();
        result.MatrixInit(diagonal.length, diagonal.length);
        for (int i = 0; i < diagonal.length; i++) {
            result.values[i][i] = diagonal[i];
        }
        return result;
    }

    public static Matrix createIdentity(int rowsN, int columnsN) {
        if (rowsN < 0 || columnsN < 0) 
        {
            throw new NumberFormatException("Wrong imput");
        }
        Matrix result = new Matrix();
        result.MatrixInit(rowsN, columnsN);
        for (int i = 0; i < rowsN; i++) {
            for (int j = 0; j < columnsN; j++) {
                result.values[i][j] = 1;
            }
        }
        return result;
    }
    public Matrix inverse() {
        if (getNumberOfRows() != getNumberOfColumns()) 
        {
            throw new NumberFormatException("NoN square matrix");
        }

        int dim = getNumberOfRows();
        double[][] result = new double[dim][dim];
        double[][] buffer = new double[dim][dim];

  
        for (int i = 0; i < buffer.length; i++) 
        {
            result[i][i] = 1;
            System.arraycopy(values[i], 0, buffer[i], 0, buffer[0].length);
        }

        for (int j = 0; j < dim; j++) 
        {
            int nonZeroI = j;
            while (nonZeroI < dim && buffer[nonZeroI][j] == 0) 
            {
                nonZeroI++;
            }
            if (nonZeroI == dim) 
            {
                throw new NumberFormatException("Inverse matrix does not exist. Determinant is 0");
            }

            swapRows(buffer, nonZeroI, j);
            swapRows(result, nonZeroI, j);

            double scalar = buffer[j][j];
            for (int j2 = 0; j2 < dim; j2++) 
            {
                result[j][j2] /= scalar;
                buffer[j][j2] /= scalar;
            }

            for (int i = j+1; i < dim; i++) {
                scalar = buffer[i][j];
                for (int j2 = 0; j2 < dim; j2++) {
                    result[i][j2] -= result[j][j2] * scalar;
                    buffer[i][j2] -= buffer[j][j2] * scalar;
                }
            }
        }

        for (int j = dim-1; j > 0; j--) 
        {
            for (int i = j-1; i >= 0; i--) 
            {
                double scalar = buffer[i][j];
                for (int j2 = 0; j2 < dim; j2++) 
                {
                    result[i][j2] -= result[j][j2] * scalar;
                }
            }
        }

        values = result;
        return this;
    }
    private void swapRows(double[][] array, int r1, int r2) {
        double[] temp = array[r1];
        array[r1] = array[r2];
        array[r2] = temp;
    }
}
    

